{"ast":null,"code":"import \"core-js/modules/es.array.map.js\";\n// Mixins\nimport CalendarBase from './calendar-base'; // Util\n\nimport props from '../util/props';\nimport { parseTime, copyTimestamp, updateMinutes, createDayList, createIntervalList, createNativeLocaleFormatter, MINUTES_IN_DAY } from '../util/timestamp';\n/* @vue/component */\n\nexport default CalendarBase.extend({\n  name: 'calendar-with-intervals',\n  props: props.intervals,\n  computed: {\n    parsedFirstInterval: function parsedFirstInterval() {\n      return parseInt(this.firstInterval);\n    },\n    parsedIntervalMinutes: function parsedIntervalMinutes() {\n      return parseInt(this.intervalMinutes);\n    },\n    parsedIntervalCount: function parsedIntervalCount() {\n      return parseInt(this.intervalCount);\n    },\n    parsedIntervalHeight: function parsedIntervalHeight() {\n      return parseFloat(this.intervalHeight);\n    },\n    parsedFirstTime: function parsedFirstTime() {\n      return parseTime(this.firstTime);\n    },\n    firstMinute: function firstMinute() {\n      var time = this.parsedFirstTime;\n      return time !== false && time >= 0 && time <= MINUTES_IN_DAY ? time : this.parsedFirstInterval * this.parsedIntervalMinutes;\n    },\n    bodyHeight: function bodyHeight() {\n      return this.parsedIntervalCount * this.parsedIntervalHeight;\n    },\n    days: function days() {\n      return createDayList(this.parsedStart, this.parsedEnd, this.times.today, this.weekdaySkips, this.maxDays);\n    },\n    intervals: function intervals() {\n      var days = this.days;\n      var first = this.firstMinute;\n      var minutes = this.parsedIntervalMinutes;\n      var count = this.parsedIntervalCount;\n      var now = this.times.now;\n      return days.map(function (d) {\n        return createIntervalList(d, first, minutes, count, now);\n      });\n    },\n    intervalFormatter: function intervalFormatter() {\n      if (this.intervalFormat) {\n        return this.intervalFormat;\n      }\n\n      var longOptions = {\n        timeZone: 'UTC',\n        hour: '2-digit',\n        minute: '2-digit'\n      };\n      var shortOptions = {\n        timeZone: 'UTC',\n        hour: 'numeric',\n        minute: '2-digit'\n      };\n      var shortHourOptions = {\n        timeZone: 'UTC',\n        hour: 'numeric'\n      };\n      return createNativeLocaleFormatter(this.currentLocale, function (tms, short) {\n        return short ? tms.minute === 0 ? shortHourOptions : shortOptions : longOptions;\n      });\n    }\n  },\n  methods: {\n    showIntervalLabelDefault: function showIntervalLabelDefault(interval) {\n      var first = this.intervals[0][0];\n      var isFirst = first.hour === interval.hour && first.minute === interval.minute;\n      return !isFirst;\n    },\n    intervalStyleDefault: function intervalStyleDefault(_interval) {\n      return undefined;\n    },\n    getTimestampAtEvent: function getTimestampAtEvent(e, day) {\n      var timestamp = copyTimestamp(day);\n      var bounds = e.currentTarget.getBoundingClientRect();\n      var baseMinutes = this.firstMinute;\n      var touchEvent = e;\n      var mouseEvent = e;\n      var touches = touchEvent.changedTouches || touchEvent.touches;\n      var clientY = touches && touches[0] ? touches[0].clientY : mouseEvent.clientY;\n      var addIntervals = (clientY - bounds.top) / this.parsedIntervalHeight;\n      var addMinutes = Math.floor(addIntervals * this.parsedIntervalMinutes);\n      var minutes = baseMinutes + addMinutes;\n      return updateMinutes(timestamp, minutes, this.times.now);\n    },\n    getSlotScope: function getSlotScope(timestamp) {\n      var scope = copyTimestamp(timestamp);\n      scope.timeToY = this.timeToY;\n      scope.timeDelta = this.timeDelta;\n      scope.minutesToPixels = this.minutesToPixels;\n      scope.week = this.days;\n      return scope;\n    },\n    scrollToTime: function scrollToTime(time) {\n      var y = this.timeToY(time);\n      var pane = this.$refs.scrollArea;\n\n      if (y === false || !pane) {\n        return false;\n      }\n\n      pane.scrollTop = y;\n      return true;\n    },\n    minutesToPixels: function minutesToPixels(minutes) {\n      return minutes / this.parsedIntervalMinutes * this.parsedIntervalHeight;\n    },\n    timeToY: function timeToY(time) {\n      var clamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var y = this.timeDelta(time);\n\n      if (y !== false) {\n        y *= this.bodyHeight;\n\n        if (clamp) {\n          if (y < 0) {\n            y = 0;\n          }\n\n          if (y > this.bodyHeight) {\n            y = this.bodyHeight;\n          }\n        }\n      }\n\n      return y;\n    },\n    timeDelta: function timeDelta(time) {\n      var minutes = parseTime(time);\n\n      if (minutes === false) {\n        return false;\n      }\n\n      var min = this.firstMinute;\n      var gap = this.parsedIntervalCount * this.parsedIntervalMinutes;\n      return (minutes - min) / gap;\n    }\n  }\n});","map":{"version":3,"mappings":"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","names":["CalendarBase","props","parseTime","copyTimestamp","updateMinutes","createDayList","createIntervalList","createNativeLocaleFormatter","MINUTES_IN_DAY","extend","name","intervals","computed","parsedFirstInterval","parseInt","firstInterval","parsedIntervalMinutes","intervalMinutes","parsedIntervalCount","intervalCount","parsedIntervalHeight","parseFloat","intervalHeight","parsedFirstTime","firstTime","firstMinute","time","bodyHeight","days","parsedStart","parsedEnd","times","today","weekdaySkips","maxDays","first","minutes","count","now","map","d","intervalFormatter","intervalFormat","longOptions","timeZone","hour","minute","shortOptions","shortHourOptions","currentLocale","tms","short","methods","showIntervalLabelDefault","interval","isFirst","intervalStyleDefault","_interval","undefined","getTimestampAtEvent","e","day","timestamp","bounds","currentTarget","getBoundingClientRect","baseMinutes","touchEvent","mouseEvent","touches","changedTouches","clientY","addIntervals","top","addMinutes","Math","floor","getSlotScope","scope","timeToY","timeDelta","minutesToPixels","week","scrollToTime","y","pane","$refs","scrollArea","scrollTop","clamp","min","gap"],"sourceRoot":"","sources":["../../../../src/components/VCalendar/mixins/calendar-with-intervals.ts"],"sourcesContent":["\n// Mixins\nimport CalendarBase from './calendar-base'\n\n// Util\nimport props from '../util/props'\nimport {\n  parseTime,\n  copyTimestamp,\n  updateMinutes,\n  createDayList,\n  createIntervalList,\n  createNativeLocaleFormatter,\n  VTime,\n  MINUTES_IN_DAY,\n} from '../util/timestamp'\nimport { CalendarTimestamp, CalendarFormatter, CalendarDayBodySlotScope } from 'vuetify/types'\n\n/* @vue/component */\nexport default CalendarBase.extend({\n  name: 'calendar-with-intervals',\n\n  props: props.intervals,\n\n  computed: {\n    parsedFirstInterval (): number {\n      return parseInt(this.firstInterval)\n    },\n    parsedIntervalMinutes (): number {\n      return parseInt(this.intervalMinutes)\n    },\n    parsedIntervalCount (): number {\n      return parseInt(this.intervalCount)\n    },\n    parsedIntervalHeight (): number {\n      return parseFloat(this.intervalHeight)\n    },\n    parsedFirstTime (): number | false {\n      return parseTime(this.firstTime)\n    },\n    firstMinute (): number {\n      const time = this.parsedFirstTime\n\n      return time !== false && time >= 0 && time <= MINUTES_IN_DAY\n        ? time\n        : this.parsedFirstInterval * this.parsedIntervalMinutes\n    },\n    bodyHeight (): number {\n      return this.parsedIntervalCount * this.parsedIntervalHeight\n    },\n    days (): CalendarTimestamp[] {\n      return createDayList(\n        this.parsedStart,\n        this.parsedEnd,\n        this.times.today,\n        this.weekdaySkips,\n        this.maxDays\n      )\n    },\n    intervals (): CalendarTimestamp[][] {\n      const days: CalendarTimestamp[] = this.days\n      const first: number = this.firstMinute\n      const minutes: number = this.parsedIntervalMinutes\n      const count: number = this.parsedIntervalCount\n      const now: CalendarTimestamp = this.times.now\n\n      return days.map(d => createIntervalList(d, first, minutes, count, now))\n    },\n    intervalFormatter (): CalendarFormatter {\n      if (this.intervalFormat) {\n        return this.intervalFormat as CalendarFormatter\n      }\n\n      const longOptions = { timeZone: 'UTC', hour: '2-digit', minute: '2-digit' }\n      const shortOptions = { timeZone: 'UTC', hour: 'numeric', minute: '2-digit' }\n      const shortHourOptions = { timeZone: 'UTC', hour: 'numeric' }\n\n      return createNativeLocaleFormatter(\n        this.currentLocale,\n        (tms, short) => short ? (tms.minute === 0 ? shortHourOptions : shortOptions) : longOptions\n      )\n    },\n  },\n\n  methods: {\n    showIntervalLabelDefault (interval: CalendarTimestamp): boolean {\n      const first: CalendarTimestamp = this.intervals[0][0]\n      const isFirst: boolean = first.hour === interval.hour && first.minute === interval.minute\n      return !isFirst\n    },\n    intervalStyleDefault (_interval: CalendarTimestamp): object | undefined {\n      return undefined\n    },\n    getTimestampAtEvent (e: MouseEvent | TouchEvent, day: CalendarTimestamp): CalendarTimestamp {\n      const timestamp: CalendarTimestamp = copyTimestamp(day)\n      const bounds = (e.currentTarget as HTMLElement).getBoundingClientRect()\n      const baseMinutes: number = this.firstMinute\n      const touchEvent: TouchEvent = e as TouchEvent\n      const mouseEvent: MouseEvent = e as MouseEvent\n      const touches: TouchList = touchEvent.changedTouches || touchEvent.touches\n      const clientY: number = touches && touches[0] ? touches[0].clientY : mouseEvent.clientY\n      const addIntervals: number = (clientY - bounds.top) / this.parsedIntervalHeight\n      const addMinutes: number = Math.floor(addIntervals * this.parsedIntervalMinutes)\n      const minutes: number = baseMinutes + addMinutes\n\n      return updateMinutes(timestamp, minutes, this.times.now)\n    },\n    getSlotScope (timestamp: CalendarTimestamp): CalendarDayBodySlotScope {\n      const scope = copyTimestamp(timestamp) as any\n      scope.timeToY = this.timeToY\n      scope.timeDelta = this.timeDelta\n      scope.minutesToPixels = this.minutesToPixels\n      scope.week = this.days\n      return scope\n    },\n    scrollToTime (time: VTime): boolean {\n      const y = this.timeToY(time)\n      const pane = this.$refs.scrollArea as HTMLElement\n\n      if (y === false || !pane) {\n        return false\n      }\n\n      pane.scrollTop = y\n\n      return true\n    },\n    minutesToPixels (minutes: number): number {\n      return minutes / this.parsedIntervalMinutes * this.parsedIntervalHeight\n    },\n    timeToY (time: VTime, clamp = true): number | false {\n      let y = this.timeDelta(time)\n\n      if (y !== false) {\n        y *= this.bodyHeight\n\n        if (clamp) {\n          if (y < 0) {\n            y = 0\n          }\n          if (y > this.bodyHeight) {\n            y = this.bodyHeight\n          }\n        }\n      }\n\n      return y\n    },\n    timeDelta (time: VTime): number | false {\n      const minutes = parseTime(time)\n\n      if (minutes === false) {\n        return false\n      }\n\n      const min: number = this.firstMinute\n      const gap: number = this.parsedIntervalCount * this.parsedIntervalMinutes\n\n      return (minutes - min) / gap\n    },\n  },\n})\n"]},"metadata":{},"sourceType":"module"}